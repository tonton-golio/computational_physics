# Scientific Computing

Your computer lies to you. It stores one-third as 0.333333333333333... and then quietly chops off the rest. Multiply by three and — surprise! — you don't always get one. That tiny lie is the first thing every scientist who uses a computer has to meet face to face.

Most equations that describe the physical world have no closed-form solution. The airflow over a wing, the quantum state of a molecule, the stress in a bridge — none of these yield to pencil and paper. You need algorithms: systematic recipes that trade exact answers for approximate ones, with guarantees on how wrong the approximation can be.

That's the heart of scientific computing. You'll learn to solve linear systems, fit models to noisy data, find roots of nonlinear equations, optimize functions with a thousand variables, decompose signals into hidden frequencies, march differential equations forward in time, and simulate heat, waves, and fluid flow across space. At every step, the question isn't just "does the algorithm give an answer?" but "how accurate is it, how fast is it, and when does it break?" That's why we're here.
